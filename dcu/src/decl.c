                 /* ******************************* */
                 /*     DCU Fuzzy Compiler          */
                 /*     Dublin City University      */
                 /* ******************************* */

#include <stdio.h>
#include <string.h>
#include "defs.h"

extern NODE *symbtab;
extern void printree();


/*********** ROUTINES TO GENERATE VARIABLE DECLARATIONS ETC. *************/

PUBLIC void init(mfile,sname)
/* Generate "#include" lines at top of file */
FILE *mfile;
char *sname;
{
	fprintf(mfile,"/*****************************************/");
	fprintf(mfile,"\n/* Generated by DCU Fuzzy Logic Compiler */");
	fprintf(mfile,"\n/* (c) Dublin City University, 1992      */");
	if (sname[0] != '\0')
		fprintf(mfile,"\n/* Source file was:  %-12s        */",sname);
	fprintf(mfile,"\n/*****************************************/");
	fprintf(mfile,"\n\n#include <stdio.h>");
	fprintf(mfile,"\n#include <stdlib.h>");
	fprintf(mfile,"\n#include <alloc.h>");
	fprintf(mfile,"\n#include <math.h>\n");
	fprintf(mfile,"\nint iround(float db)\n{");
	fprintf(mfile,"\n\treturn ((int) (db - floor(db) >= 0.5) ? (db+1) : (db));\n}");
	fprintf(mfile,"\n\n");
}


/* Define MEW for the specified form of reasoning (max-min or max-dot) */

PUBLIC void maxdot(mfile)
FILE *mfile;
{
	fprintf(mfile,"\n\n/* Reasoning strategy is MAX-DOT */");
	fprintf(mfile,"\n#define MEW(a,b)   ((a)*(b))");
}

PUBLIC void maxmin(mfile)
FILE *mfile;
{
	fprintf(mfile,"\n\n/* Reasoning strategy is MAX-MIN */");
	fprintf(mfile,"\n#define MEW(a,b)   ((a) < (b)) ? (a) : (b)");
}



PUBLIC void merge(mfile,rfile)
/* Merge the delcarations and rules files */
FILE *mfile, *rfile;
{
	int i;
	char buf[100];
	rewind(rfile);
	i = fread(buf,sizeof(char),1,rfile);
	while (i != 0) {
		fwrite(buf,sizeof(char),1,mfile);
		i = fread(buf,sizeof(char),1,rfile);
	}
}



/***** GENERATE INPUT- AND OUTPUT- (GLOBAL) VARIABLE DECLARATIONS *****/

static char decl[150];
		/* To hold the declaration for the main "rules" function */


static NODE *outmap[25]; 	/* just a list of all the output variables */
static int outnum=0;      /* An index into <outmap> */

extern int iround();




PRIVATE void print_decl(mfile,vnode)
/* At node <vnode> in the symbol table, so print relevant declarations */
/* Store a list of the output variables in <outmap> for use later */
FILE *mfile;
NODE *vnode;
{
	VAR *tvar;
	char a_decl[30];
	if (vnode->ntype != NVAR) return;
	tvar = (VAR *)vnode->contents;
	if (tvar->io == INP) {
		/* Input ==> just add declaration to <decl> */
		sprintf(a_decl,"%s %s, ",tvar->type,vnode->name);
		strcat(decl,a_decl);
	}
	else if (tvar->io == OUTP) {
		if (outnum <= 24)
			outmap[outnum++] = vnode;   /* Store for use in following functions */
		fprintf(mfile,"\n\t%s %s;",tvar->type,vnode->name);
	}
}


PUBLIC void globals(mfile,pname)
/* Go through the symbol table, calling <print_decl> for each node */
FILE *mfile;
char *pname;
{
	fprintf(mfile,"\n\n\n/* Structure to hold the returned (crisp output) values */");
	fprintf(mfile,"\ntypedef struct {");
	printree(mfile,symbtab,print_decl);
	fprintf(mfile,"\n} CRISP;");
	fprintf(mfile,"\n\n\nvoid %s(%s CRISP *crisp)\n{",pname,decl);
}


/****************** GENERATE LOCAL VARIABLE DECLARATIONS ****************/

PUBLIC void locals(mfile,numtemps)
/* Generate declarations for local variables in the main routine */
FILE *mfile;
int numtemps;  /* No. of temp. variables to declare */
{
	int i;

	/* (1) Ordinary local variables */
	fprintf(mfile,"\n\tint i, indx;");
	fprintf(mfile,"\n\tfloat map_i, v_i, area, moment;");

	/* (2) Temporary variables */
	fprintf(mfile,"\n\tfloat ");
	for (i=1; i<numtemps; i++) {
		fprintf(mfile,"t%03d, ",i);
		if ((i != 0) && ((i/10)*10 == i))
			fprintf(mfile,"\n\t    ");     /* Max. of 10 per line */
	}
	fprintf(mfile,"t%03d;",numtemps);

	/* (3) Temporary output maps */
	if (outnum != 0)  {
		fprintf(mfile,"\n\tfloat ");
		for (i=0; i<outnum-1; i++) {
			fprintf(mfile,"*O_%s, ",outmap[i]->name);
			if ((i != 0) && ((i/10)*10 == i))
				fprintf(mfile,"\n\t    ");     /* Max. of 10 per line */
		}
		fprintf(mfile,"*O_%s;",outmap[i]->name);
	}
}



PUBLIC void calc_crisp(mfile,rfile)
/* Go through <outmap>, generating code to allocate space */
/* and to calculate the crisp (output) values */
FILE *mfile, *rfile;
{
	char *vname;
	VAR *tvar;
	int i, msize;

	fprintf(mfile,"\n\n\t/*** Allocate memory for output maps ***/");
	for (i=0; i<outnum; i++) {
		vname = outmap[i]->name;
		tvar = (VAR *) outmap[i]->contents;
		msize = iround((tvar->max-tvar->min)/tvar->step) +1;
		/* Add memory allocation to <mfile> */
		fprintf(mfile,"\n\tO_%s = (float *) calloc(%d,sizeof(float));",vname,msize);
		/* Add crisp-value calculation to <rfile> */
		fprintf(rfile,"\n\n\t/***** Calculate crisp value for variable %s ******/",vname);
		fprintf(rfile,"\n\tarea = 0;  moment = 0;");
		fprintf(rfile,"\n\tfor(i=0; i<%d; i++)  {",msize);
		fprintf(rfile,"\n\t\tmap_i = O_%s[i];",vname);
		fprintf(rfile,"\n\t\tv_i   = %f + (%f * (float)i);",tvar->min,tvar->step);
		fprintf(rfile,"\n\t\tarea += map_i;");
		fprintf(rfile,"\n\t\tmoment += map_i * v_i;");
		fprintf(rfile,"\n\t}");
		fprintf(rfile,"\n\tif (area == 0) { /* Divide by zero error */");
		fprintf(rfile,"\n\t\tcrisp->%s = (%f + %f); /* Bigger than max. */",vname,tvar->max,tvar->step);
		fprintf(rfile,"\n\t}");
		fprintf(rfile,"\n\telse");
		fprintf(rfile,"\n\t\tcrisp->%s = (moment / area);",vname);
		fprintf(rfile,"\n\tfree(O_%s);",vname);
	}
	fprintf(rfile,"\n}");
	fprintf(rfile,"\n\n/***** END OF FUZZY KNOWLEDGE BASE *****/");
}
