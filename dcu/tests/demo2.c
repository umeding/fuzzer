/*****************************************/
/* Generated by DCU Fuzzy Logic Compiler */
/* (c) Dublin City University, 1992      */
/* Source file was:  demo2.fuz           */
/*****************************************/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int iround(float db)
{
	return ((int) (db - floorf(db) >= 0.5) ? (db+1) : (db));
}



static short int Tta_PB[] = {
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,  26,  51,  77, 102, 128, 153, 179, 204, 230, 
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 
    255
};

static short int Veloc_Z[] = {
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,  26,  51,  77, 102, 128, 153, 179, 204, 230, 
    255, 230, 204, 179, 153, 128, 102,  76,  51,  25, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0,   0,   0,   0,   0,   0,   0,   0,   0,   0, 
      0
};

/* Reasoning strategy is MAX-DOT */
/*#define MEW(a,b)   ((a)*(b))*/
/*#define max(a,b)   ((a)>(b)?(a):(b))*/

float MEW(float a, float b) {
    return a * b;
}
float max(float a, float b) {
    return a > b ? a : b;
}

/* Structure to hold the returned (crisp output) values */
typedef struct {
	float Veloc;
} CRISP;


void Yan(int Tta, float dTheta,  CRISP *crisp)
{
	int i, indx;
	float map_i, v_i, area, moment;
	float t001;
	float *O_Veloc;

	/*** Allocate memory for output maps ***/
	O_Veloc = (float *) calloc(101,sizeof(float));

	/*****   CODE FOR RULE: Rue0001   *****/
	/* Tta is  PB */
	indx = iround((float)(Tta - (int)-50.000000) / (float)1.000000);
	t001 = (float)Tta_PB[indx] / 255.0;
	/* Fire strength (alpha) is t001 */
	if (t001 != 0.0)  {
		/* Union with output array for <Veloc> */
		for (i=0; i<101; i++) {
			map_i = (float)Veloc_Z[i] / 255.0;
			O_Veloc[i] = max(O_Veloc[i], MEW(t001, map_i));
		}
	}

	/***** Calculate crisp value for variable Veloc ******/
	area = 0;  moment = 0;
	for(i=0; i<101; i++)  {
		map_i = O_Veloc[i];
		v_i   = -5.000000 + (0.100000 * (float)i);
		area += map_i;
		moment += map_i * v_i;
	}
	if (area == 0) { /* Divide by zero error */
		crisp->Veloc = (5.000000 + 0.100000); /* Bigger than max. */
	}
	else
		crisp->Veloc = (moment / area);
	free(O_Veloc);
}

void main() {

    CRISP crisp;
    int i;

    for(i=10;i<35;i++) {
        Yan(i,0,&crisp);
        printf("%d -> %f\n", i, crisp.Veloc);
    }
}

/***** END OF FUZZY KNOWLEDGE BASE *****/
